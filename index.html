<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake in a Box - Hypercube Game</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
        height: 100vh;
        overflow: hidden;
      }

      .container {
        width: 100vw;
        height: 100vh;
        background: white;
        display: flex;
        flex-direction: column;
      }

      .header {
        height: 64px;
        padding: 8px 12px;
        background: #f8f9fa;
        border-bottom: 1px solid #ddd;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
      }

      .header-left {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .header-title {
        font-weight: bold;
        margin-right: 8px;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .control-group label {
        font-size: 12px;
        margin: 0;
      }

      select,
      button,
      textarea {
        padding: 4px 8px;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-size: 12px;
      }

      select,
      button {
        height: 28px;
      }

      textarea {
        resize: none;
        font-family: monospace;
        min-height: 28px;
        width: 200px;
      }

      textarea.error {
        border-color: #dc3545;
        background-color: #f8d7da;
      }

      button {
        background: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 11px;
      }

      .game-area {
        position: relative;
        background: #fff;
        flex: 1;
        overflow: hidden;
      }

      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .coordinate {
        font-family: monospace;
        background: #fff;
        padding: 2px 4px;
        border-radius: 3px;
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-left">
          <div class="header-title">Snake in a Box</div>
          <div class="control-group">
            <label for="dimension">Dim:</label>
            <select id="dimension">
              <option value="1">1D</option>
              <option value="2">2D</option>
              <option value="3" selected>3D</option>
              <option value="4">4D</option>
              <option value="5">5D</option>
              <option value="6">6D</option>
              <option value="7">7D</option>
              <option value="8">8D</option>
              <option value="9">9D</option>
              <option value="10">10D</option>
            </select>
          </div>
          <div class="control-group">
            <button id="restart">Restart</button>
            <button id="undo" disabled>Undo</button>
          </div>
        </div>
        <div class="header-right">
          <div class="control-group">
            <label for="sequence">Sequence:</label>
            <textarea
              id="sequence"
              placeholder="Dimension switches..."
            ></textarea>
          </div>
          <div>
            <span class="coordinate" id="currentPos">(0,0,0)</span>
          </div>
          <div>Length: <span id="pathLength">0</span></div>
          <div>
            <a
              href="?d=8&p=61301621520127026102742016234261245126170162152012302610234201627426124571026123421620172162472610"
              >8D Record</a
            >
          </div>
        </div>
      </div>

      <div class="game-area" id="gameArea">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>

    <script>
      class SnakeInBox {
        constructor() {
          this.dimension = 3;
          this.currentPosition = new Array(this.dimension).fill(0);
          this.path = [this.currentPosition.slice()];
          this.gameArea = document.getElementById("gameArea");
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.vertices = new Map();
          this.animationId = null;

          this.init();
        }

        init() {
          // Initialize from URL parameters
          this.initFromURL();

          document
            .getElementById("dimension")
            .addEventListener("change", (e) => {
              this.dimension = parseInt(e.target.value);
              this.restart();
              this.updateURL();
            });

          document.getElementById("restart").addEventListener("click", () => {
            this.restart();
          });

          document.getElementById("undo").addEventListener("click", () => {
            this.undo();
          });

          this.canvas.addEventListener("click", (e) => {
            this.handleCanvasClick(e);
          });

          document.getElementById("sequence").addEventListener("input", (e) => {
            this.handleSequenceInput(e.target.value);
          });

          document.addEventListener("keydown", (e) => {
            this.handleKeyDown(e);
          });

          window.addEventListener("resize", () => {
            this.resizeCanvas();
            this.generateVertices();
            this.render();
          });

          this.resizeCanvas();
          this.generateVertices();
          this.updateUI();
          this.render();
          this.startAnimationLoop();
        }

        initFromURL() {
          const urlParams = new URLSearchParams(window.location.search);

          // Set dimension from URL parameter 'd'
          const dimension = urlParams.get("d");
          if (dimension && !isNaN(dimension)) {
            const dimValue = parseInt(dimension);
            if (dimValue >= 1 && dimValue <= 10) {
              this.dimension = dimValue;
              document.getElementById("dimension").value = dimValue;
            }
          }

          // Set path from URL parameter 'p'
          const pathParam = urlParams.get("p");
          if (pathParam) {
            const textarea = document.getElementById("sequence");
            textarea.value = pathParam;
            try {
              const path = this.parseSequence(pathParam);
              if (path) {
                this.path = path;
                this.currentPosition = path[path.length - 1].slice();
                textarea.classList.remove("error");
                return; // Don't reset to default path
              }
            } catch (error) {
              // If path is invalid, show it in red but use default path
              textarea.classList.add("error");
            }
          }

          // If no valid path from URL, use default starting position
          this.currentPosition = new Array(this.dimension).fill(0);
          this.path = [this.currentPosition.slice()];
        }

        updateURL() {
          const urlParams = new URLSearchParams();
          urlParams.set("d", this.dimension);

          const sequence = this.generateSequence();
          if (sequence) {
            urlParams.set("p", sequence);
          }

          const newURL = window.location.pathname + "?" + urlParams.toString();
          window.history.replaceState({}, "", newURL);
        }

        resizeCanvas() {
          const rect = this.gameArea.getBoundingClientRect();
          this.canvas.width = rect.width;
          this.canvas.height = rect.height;
        }

        restart() {
          this.currentPosition = new Array(this.dimension).fill(0);
          this.path = [this.currentPosition.slice()];
          this.generateVertices();
          this.updateUI();
          this.updateURL();
          this.render();
        }

        generateVertices() {
          this.vertices.clear();
          const totalVertices = Math.pow(2, this.dimension);
          const areaWidth = this.canvas.width;
          const areaHeight = this.canvas.height;

          for (let i = 0; i < totalVertices; i++) {
            const coords = this.numberToBinaryCoords(i, this.dimension);
            const position = this.coordsToPosition(
              coords,
              areaWidth,
              areaHeight,
            );

            this.vertices.set(this.coordsToString(coords), {
              coords: coords,
              position: position,
              size: this.getVertexSize(),
            });
          }
        }

        getVertexSize() {
          const W = Math.min(this.canvas.width, this.canvas.height) * 0.85;
          const ceilHalfD = Math.ceil(this.dimension / 2);
          const spacing = W / Math.pow(2, ceilHalfD);
          return spacing * 0.9;
        }

        coordsToPosition(coords, areaWidth, areaHeight) {
          const W = Math.min(areaWidth, areaHeight) * 0.85;
          const D = this.dimension;
          const ceilHalfD = Math.ceil(D / 2);
          const spacing = W / Math.pow(2, ceilHalfD);

          const centerX = areaWidth / 2;
          const centerY = areaHeight / 2;

          const maxCoordX = Math.ceil(D / 2) - 1;
          const maxCoordY = Math.floor(D / 2) - 1;

          let gridX = 0;
          let gridY = 0;

          for (let i = 0; i < coords.length; i++) {
            const power = Math.pow(2, Math.floor(i / 2));

            if (i % 2 === 0) {
              gridX += coords[i] * power;
            } else {
              gridY += coords[i] * power;
            }
          }

          const x = centerX + (gridX - Math.pow(2, maxCoordX)) * spacing;
          const y = centerY + (gridY - Math.pow(2, maxCoordY)) * spacing;

          return { x, y };
        }

        handleCanvasClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;

          for (const [coordsStr, vertex] of this.vertices) {
            const dx = clickX - vertex.position.x;
            const dy = clickY - vertex.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= vertex.size / 2) {
              this.handleDotClick(vertex.coords);
              break;
            }
          }
        }

        handleKeyDown(e) {
          const textarea = document.getElementById("sequence");

          // If textarea is already focused, let default behavior handle it
          if (document.activeElement === textarea) {
            return;
          }

          // Handle digit keys (0-9)
          if (e.key >= "0" && e.key <= "9") {
            e.preventDefault();
            textarea.focus();
            textarea.value += e.key;
            this.handleSequenceInput(textarea.value);
          }
          // Handle backspace
          else if (e.key === "Backspace") {
            e.preventDefault();
            textarea.focus();
            if (textarea.value.length > 0) {
              textarea.value = textarea.value.slice(0, -1);
              this.handleSequenceInput(textarea.value);
            }
          }
        }

        startAnimationLoop() {
          const animate = () => {
            this.render();
            this.animationId = requestAnimationFrame(animate);
          };
          animate();
        }

        render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          for (const [coordsStr, vertex] of this.vertices) {
            this.drawVertex(vertex);
          }

          this.drawPath();
        }

        drawVertex(vertex) {
          const { coords, position, size } = vertex;
          const { x, y } = position;
          const halfSize = size / 2;

          let fillColor, strokeColor;

          if (this.arraysEqual(coords, this.currentPosition)) {
            const pulseIntensity = (Math.sin(Date.now() / 200) + 1) / 2;
            const r = Math.floor(120 + (160 - 120) * pulseIntensity);
            fillColor = `rgb(${r}, 20, 30)`;
            strokeColor = "#8b0000";
          } else if (this.isVisited(coords)) {
            fillColor = "#ffc107";
            strokeColor = "#e0a800";
          } else if (this.isAdjacent(this.currentPosition, coords)) {
            if (this.isBlocked(coords)) {
              fillColor = "#6c757d";
              strokeColor = "#545b62";
            } else {
              fillColor = "#17a2b8";
              strokeColor = "#138496";
            }
          } else {
            fillColor = "#333";
            strokeColor = "#666";
          }

          this.ctx.fillStyle = fillColor;
          this.ctx.strokeStyle = strokeColor;
          this.ctx.lineWidth = 2;

          this.ctx.fillRect(x - halfSize, y - halfSize, size, size);
          this.ctx.strokeRect(x - halfSize, y - halfSize, size, size);

          // Draw dimension number for valid moves
          if (
            this.isAdjacent(this.currentPosition, coords) &&
            !this.isBlocked(coords)
          ) {
            const dimension = this.getDimensionDifference(
              this.currentPosition,
              coords,
            );
            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = `${Math.floor(size * 0.8)}px Arial`;
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(dimension.toString(), x, y);
          }
        }

        drawPath() {
          if (this.path.length < 2) return;

          this.ctx.strokeStyle = "#dc3545";
          this.ctx.lineWidth = 3;

          const W = Math.min(this.canvas.width, this.canvas.height) * 0.85;
          const ceilHalfD = Math.ceil(this.dimension / 2);
          const spacing = W / Math.pow(2, ceilHalfD);

          for (let i = 1; i < this.path.length; i++) {
            const from = this.coordsToPosition(
              this.path[i - 1],
              this.canvas.width,
              this.canvas.height,
            );
            const to = this.coordsToPosition(
              this.path[i],
              this.canvas.width,
              this.canvas.height,
            );

            const pathIndex = i - 1;
            let jitterValue = 0;
            let jump = pathIndex % 2 === 1 ? 0.1 : 0;

            if (pathIndex > 0) {
              const step = Math.floor((pathIndex + 1) / 2);
              jitterValue = step * 0.2;
            }

            const pathLength = this.path.length - 1;
            const deltaScale = spacing / Math.max(pathLength, 1);
            const jitterOffset = jitterValue * deltaScale + spacing * jump;

            let fromX = from.x;
            let fromY = from.y;
            let toX = to.x;
            let toY = to.y;

            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const isHorizontal = Math.abs(dx) > Math.abs(dy);

            if (isHorizontal) {
              fromY += jitterOffset;
              toY += jitterOffset;
            } else {
              fromX += jitterOffset;
              toX += jitterOffset;
            }

            this.ctx.beginPath();
            this.ctx.moveTo(fromX, fromY);
            this.ctx.lineTo(toX, toY);
            this.ctx.stroke();
          }
        }

        numberToBinaryCoords(num, dimension) {
          const coords = [];
          for (let i = 0; i < dimension; i++) {
            coords.push((num >> i) & 1);
          }
          return coords;
        }

        coordsToString(coords) {
          return coords.join(",");
        }

        arraysEqual(a, b) {
          return a.length === b.length && a.every((val, i) => val === b[i]);
        }

        isAdjacent(coords1, coords2) {
          let differences = 0;
          for (let i = 0; i < coords1.length; i++) {
            if (coords1[i] !== coords2[i]) {
              differences++;
              if (differences > 1) return false;
            }
          }
          return differences === 1;
        }

        getDimensionDifference(coords1, coords2) {
          for (let i = 0; i < coords1.length; i++) {
            if (coords1[i] !== coords2[i]) {
              return i;
            }
          }
          return -1; // Should not happen for adjacent coordinates
        }

        isVisited(coords) {
          return this.path.some((pathCoords) =>
            this.arraysEqual(pathCoords, coords),
          );
        }

        isBlocked(coords) {
          if (this.isVisited(coords)) return true;

          // For snake in a box, no part of the path can be adjacent to any other
          // path points except the points immediately before or after
          for (let i = 0; i < this.path.length - 1; i++) {
            if (this.isAdjacent(coords, this.path[i])) {
              return true;
            }
          }

          return false;
        }

        handleDotClick(coords) {
          if (!this.isAdjacent(this.currentPosition, coords)) {
            return;
          }

          if (this.isBlocked(coords)) {
            return;
          }

          this.currentPosition = coords.slice();
          this.path.push(coords.slice());

          this.updateUI();
          this.updateURL();
          document.getElementById("undo").disabled = this.path.length <= 1;
        }

        undo() {
          if (this.path.length <= 1) return;

          this.path.pop();
          this.currentPosition = this.path[this.path.length - 1].slice();

          this.updateUI();
          this.updateURL();
          document.getElementById("undo").disabled = this.path.length <= 1;
        }

        updateUI() {
          document.getElementById("currentPos").textContent =
            `(${this.currentPosition.join(",")})`;
          document.getElementById("pathLength").textContent =
            this.path.length - 1;
          this.updateSequenceDisplay();
        }

        generateSequence() {
          const sequence = [];
          for (let i = 1; i < this.path.length; i++) {
            const prev = this.path[i - 1];
            const curr = this.path[i];
            for (let dim = 0; dim < this.dimension; dim++) {
              if (prev[dim] !== curr[dim]) {
                sequence.push(dim);
                break;
              }
            }
          }
          return sequence.join("");
        }

        updateSequenceDisplay() {
          const textarea = document.getElementById("sequence");
          if (document.activeElement !== textarea) {
            textarea.value = this.generateSequence();
            textarea.classList.remove("error");
          }
        }

        handleSequenceInput(sequenceStr) {
          const textarea = document.getElementById("sequence");
          try {
            const path = this.parseSequence(sequenceStr);
            if (path) {
              this.path = path;
              this.currentPosition = path[path.length - 1].slice();
              this.updateUI();
              this.updateURL();
              this.render();
              textarea.classList.remove("error");
              document.getElementById("undo").disabled = this.path.length <= 1;
            }
          } catch (error) {
            textarea.classList.add("error");
          }
        }

        parseSequence(sequenceStr) {
          if (!sequenceStr.trim()) {
            return [new Array(this.dimension).fill(0)];
          }

          const moves = sequenceStr
            .split("")
            .filter((c) => {
              return (
                c !== " " && c !== "\t" && c !== "\n" && c !== "," && c !== "\r"
              );
            })
            .map((c) => {
              const dim = parseInt(c);
              if (isNaN(dim) || dim < 0 || dim >= this.dimension) {
                throw new Error(`Invalid dimension: ${c}`);
              }
              return dim;
            });

          const path = [new Array(this.dimension).fill(0)];
          let current = new Array(this.dimension).fill(0);

          for (const dim of moves) {
            const next = current.slice();
            next[dim] = 1 - next[dim]; // flip the bit

            // Validate the move
            if (!this.isAdjacent(current, next)) {
              throw new Error("Invalid move: not adjacent");
            }

            // Check if we're revisiting a vertex
            for (let i = 0; i < path.length; i++) {
              if (this.arraysEqual(path[i], next)) {
                throw new Error("Invalid path: revisiting vertex");
              }
            }

            // Check adjacency constraint: no part of path can be adjacent
            // to any other path points except immediately before/after
            for (let i = 0; i < path.length - 1; i++) {
              if (this.isAdjacent(next, path[i])) {
                throw new Error("Invalid path: adjacency violation");
              }
            }

            path.push(next.slice());
            current = next;
          }

          return path;
        }
      }

      window.addEventListener("load", () => {
        window.snakeGame = new SnakeInBox();
      });
    </script>
  </body>
</html>
